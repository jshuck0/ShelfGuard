"""
Daily Brief Tab: Morning Brew Style Intelligence Report

This is the UI for the AI Strategic Intelligence Agent (Generation 3/4).
It displays the Daily Brief generated by the new Causal Reasoning Engine.

Architecture:
- Uses the new Orchestrator (Layer 3) which coordinates:
  - Profiler (Triage)
  - Tools (Calibrator, Volatility, Prediction, Causal, Cluster)
  - LLM Synthesis (Strategic Narratives)

The vibe: Newsletter (like Morning Brew), NOT a system alert.
"""

import streamlit as st
import pandas as pd
from datetime import datetime
from typing import Optional, List, Dict, Any, Tuple

# Import Supabase loader for fallback
try:
    from src.supabase_reader import load_weekly_timeseries
    SUPABASE_LOADER_AVAILABLE = True
except ImportError:
    SUPABASE_LOADER_AVAILABLE = False

# Import new analyst components (Generation 3/4)
try:
    from src.analyst import (
        # Orchestrator
        run_sherlock_analysis,
        OrchestratorOutput,
        StrategicNarrative,
        get_quick_vitals,
        # Config & Profiler
        run_profiler,
        ProfilerVitals,
        # Brief
        MarketContext,
        DiagnosticBrief,
    )
    from src.analyst.world_context import get_world_context
    NEW_ANALYST_AVAILABLE = True
except ImportError as e:
    NEW_ANALYST_AVAILABLE = False
    print(f"New analyst module import error: {e}")

# Legacy imports for backward compatibility
try:
    from src.analyst.models import DailyBrief as LegacyDailyBrief
    from src.analyst.event_stream import transform_to_event_stream, get_event_summary
    from src.analyst.sherlock_engine import run_sherlock_sync
    LEGACY_AVAILABLE = True
except ImportError:
    LEGACY_AVAILABLE = False


def render_daily_brief_tab():
    """Render the Daily Brief tab with Morning Brew style UI."""
    
    # Header
    st.markdown("# üì∞ Daily Brief")
    st.caption("Strategic narratives from your AI Analyst ‚Ä¢ ShelfGuard Intelligence (Gen 3/4)")
    
    if not NEW_ANALYST_AVAILABLE:
        if LEGACY_AVAILABLE:
            st.warning("Using legacy analyst. New causal engine not available.")
            _render_legacy_mode()
        else:
            st.error("‚ö†Ô∏è Analyst module not available. Check import errors.")
        return
    
    # Check for active project
    active_project_asin = st.session_state.get('active_project_asin', None)
    project_asins = st.session_state.get('active_project_all_asins', [])
    df_weekly = st.session_state.get('df_weekly', pd.DataFrame())
    
    # Fallback: If df_weekly is empty but we have ASINs, try loading from Supabase
    if df_weekly.empty and project_asins and SUPABASE_LOADER_AVAILABLE:
        with st.spinner("üì¶ Loading historical data from cache..."):
            df_weekly = load_weekly_timeseries(tuple(project_asins), days=90)
            if not df_weekly.empty:
                st.session_state['df_weekly'] = df_weekly
                st.caption(f"‚úÖ Loaded {len(df_weekly)} weekly records from cache")
    
    if not active_project_asin or df_weekly.empty:
        _render_no_project_state()
        return
    
    # Get project info
    project_name = st.session_state.get('active_project_name', 'Your Market')
    target_brand = st.session_state.get('active_brand', '')
    
    # Check if we have a cached analysis
    cached_output = st.session_state.get('orchestrator_output', None)
    
    col1, col2, col3 = st.columns([2, 1, 1])
    with col1:
        st.markdown(f"**Market:** {project_name}")
        if target_brand:
            st.caption(f"Your Brand: {target_brand}")
    
    with col2:
        if st.button("üîÑ Regenerate", type="primary", use_container_width=True):
            cached_output = None
            st.session_state.pop('orchestrator_output', None)
            st.rerun()
    
    with col3:
        if st.button("‚ö° Quick Vitals", use_container_width=True):
            _show_quick_vitals(df_weekly, active_project_asin)
    
    st.markdown("---")
    
    # Generate or display analysis
    if cached_output is None:
        with st.spinner("üîç Running Causal Reasoning Engine..."):
            output = _generate_analysis(df_weekly, active_project_asin, target_brand)
            if output:
                st.session_state['orchestrator_output'] = output
                cached_output = output
    
    if cached_output:
        _render_orchestrator_output(cached_output)
    else:
        st.warning("Could not generate analysis. Check that you have data loaded.")


def _render_no_project_state():
    """Render empty state when no project is active."""
    st.markdown("### üì≠ No Market Loaded")
    st.info("Load a market in **Command Center** or **Market Discovery** to generate your Daily Brief.")
    
    # Show what the engine can do
    with st.expander("‚ÑπÔ∏è What the Causal Reasoning Engine Does"):
        st.markdown("""
        **The Self-Driving Analyst (Generation 3/4)**
        
        1. **Profiler** - Triages data health and trends
        2. **Calibrator** - Learns product-specific physics (elasticity, Amazon impact)
        3. **Volatility Sensor** - Detects anomalies and regime changes
        4. **Prediction Engine** - Holt-Winters forecasting
        5. **Causal Sensor** - Granger causality testing
        6. **Cluster Engine** - Market segmentation
        7. **LLM Synthesizer** - Strategic narrative generation
        
        All math is done in Python. The AI only sees structured briefs.
        """)


def _show_quick_vitals(df_weekly: pd.DataFrame, asin: str):
    """Show quick vitals without full analysis."""
    with st.spinner("Getting vitals..."):
        vitals = get_quick_vitals(df_weekly, asin)
    
    col1, col2, col3 = st.columns(3)
    with col1:
        health = vitals.get("health", "UNKNOWN")
        color = {"HEALTHY": "üü¢", "AT_RISK": "üü°", "CRITICAL": "üî¥"}.get(health, "‚ö™")
        st.metric("Health", f"{color} {health}")
    with col2:
        confidence = vitals.get("confidence", 0)
        st.metric("Confidence", f"{confidence:.0%}")
    with col3:
        alerts = vitals.get("alerts", [])
        st.metric("Alerts", len(alerts))
    
    if vitals.get("trends"):
        st.markdown("**Trends:**")
        for metric, direction in vitals["trends"].items():
            icon = "üìà" if direction == "GROWING" else "üìâ" if direction == "DECLINING" else "‚û°Ô∏è"
            st.write(f"  {icon} {metric}: {direction}")


def _generate_analysis(
    df_weekly: pd.DataFrame, 
    seed_asin: str, 
    target_brand: str
) -> Optional[OrchestratorOutput]:
    """Generate analysis using the new Causal Reasoning Engine."""
    try:
        # Build product info
        product_info = _extract_product_info(df_weekly, seed_asin, target_brand)
        
        # Get market context
        st.write("üìÖ Loading world context...")
        world_context_dict = get_world_context()
        market_context = MarketContext(
            season=world_context_dict.get("season", "UNKNOWN"),
            upcoming_events=world_context_dict.get("upcoming_events", []),
            holidays=world_context_dict.get("holidays", []),
        )
        
        # Get summary data for clustering (one row per product)
        st.write("üìä Preparing data for analysis...")
        df_summary = _get_product_summary(df_weekly)
        
        # Run the Orchestrator
        st.write("üß† Running Causal Reasoning Engine...")
        st.write("  ‚Üí Profiler (Triage)")
        st.write("  ‚Üí Calibrator (Learning Physics)")
        st.write("  ‚Üí Volatility Sensor (Anomalies)")
        st.write("  ‚Üí Prediction Engine (Forecasting)")
        st.write("  ‚Üí Causal Sensor (Root Cause)")
        st.write("  ‚Üí LLM Synthesizer (Narratives)")
        
        # Get OpenAI API key from secrets
        openai_key = st.secrets.get("openai", {}).get("OPENAI_API_KEY")
        
        output = run_sherlock_analysis(
            df_weekly=df_weekly,
            asin=seed_asin,
            product_info=product_info,
            market_context=market_context,
            journal_entries=None,  # TODO: Load from journal
            df_summary=df_summary,
            openai_api_key=openai_key,
        )
        
        st.write(f"‚úÖ Analysis complete in {output.processing_time_seconds:.1f}s")
        
        if output.errors:
            for error in output.errors:
                st.warning(f"‚ö†Ô∏è {error}")
        
        return output
        
    except Exception as e:
        st.error(f"Error generating analysis: {e}")
        import traceback
        st.code(traceback.format_exc())
        return None


def _extract_product_info(df_weekly: pd.DataFrame, asin: str, brand: str) -> Dict[str, Any]:
    """Extract product info from the data."""
    info = {
        "asin": asin,
        "brand": brand,
        "is_own": True,
    }
    
    # Try to get from the data
    if 'title' in df_weekly.columns:
        asin_data = df_weekly[df_weekly['asin'] == asin]
        if not asin_data.empty:
            info["title"] = asin_data['title'].iloc[0] if 'title' in asin_data else ""
            info["category"] = asin_data['category'].iloc[0] if 'category' in asin_data else ""
    
    # Get price for tier
    if 'buy_box_price' in df_weekly.columns:
        info["price"] = df_weekly['buy_box_price'].median()
    elif 'filled_price' in df_weekly.columns:
        info["price"] = df_weekly['filled_price'].median()
    
    return info


def _get_product_summary(df_weekly: pd.DataFrame) -> pd.DataFrame:
    """Get one row per product for clustering."""
    if 'asin' not in df_weekly.columns:
        return df_weekly
    
    # Aggregate to one row per ASIN using latest values
    agg_funcs = {}
    
    for col in df_weekly.columns:
        if col == 'asin':
            continue
        if col in ['week_start', 'week']:
            continue
        if df_weekly[col].dtype in ['int64', 'float64']:
            agg_funcs[col] = 'last'  # Use most recent value
        else:
            agg_funcs[col] = 'first'
    
    if agg_funcs:
        return df_weekly.groupby('asin').agg(agg_funcs).reset_index()
    return df_weekly


def _render_orchestrator_output(output: OrchestratorOutput):
    """Render the Orchestrator output in Morning Brew style."""
    
    # Header with brief info
    if output.brief:
        summary = output.brief.executive_summary
        st.markdown(f"## {summary.headline or 'Analysis Complete'}")
        
        # Metrics row
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            health_icons = {
                "HEALTHY": "üü¢",
                "AT_RISK": "üü°", 
                "CRITICAL": "üî¥",
                "STABLE": "üîµ"
            }
            icon = health_icons.get(summary.overall_health, "‚ö™")
            st.metric("Health", f"{icon} {summary.overall_health}")
        with col2:
            st.metric("Confidence", f"{summary.confidence_score:.0%}")
        with col3:
            st.metric("Narratives", len(output.narratives))
        with col4:
            st.metric("Tokens Used", f"{output.tokens_used:,}")
    
    st.divider()
    
    # Narratives
    if output.narratives:
        for i, narrative in enumerate(output.narratives, 1):
            _render_narrative(narrative, i)
    else:
        st.info("No strategic narratives generated. This may indicate stable market conditions or insufficient data.")
    
    # Red Team Section
    if output.red_team and output.red_team.vulnerabilities:
        st.divider()
        _render_red_team(output.red_team)
    
    # Key Metrics to Watch
    if output.key_metrics:
        st.divider()
        st.markdown("### üìä Key Metrics to Watch")
        for metric in output.key_metrics:
            st.write(f"  ‚Ä¢ {metric}")
    
    # Diagnostic Brief Details (collapsed)
    if output.brief:
        with st.expander("üî¨ Diagnostic Brief Details"):
            _render_diagnostic_details(output.brief)
    
    # Errors/Warnings
    if output.errors:
        with st.expander("‚ö†Ô∏è Warnings"):
            for error in output.errors:
                st.warning(error)


def _render_narrative(narrative: StrategicNarrative, index: int):
    """Render a single narrative card."""
    
    # Color by type
    type_colors = {
        "OPPORTUNITY": ("#10b981", "üí∞"),
        "THREAT": ("#ef4444", "‚ö†Ô∏è"),
        "INSIGHT": ("#3b82f6", "üí°"),
        "WARNING": ("#f59e0b", "üîî"),
    }
    
    color, icon = type_colors.get(narrative.narrative_type, ("#3b82f6", "üìà"))
    
    with st.container():
        # Header
        header_cols = st.columns([3, 1])
        with header_cols[0]:
            st.markdown(f"<span style='color:{color};font-weight:600;'>{icon} {narrative.narrative_type}</span>", unsafe_allow_html=True)
        with header_cols[1]:
            urgency_badge = ""
            if narrative.urgency == "IMMEDIATE":
                urgency_badge = '<span style="background:#ef4444;color:white;padding:2px 8px;border-radius:4px;font-size:11px;">IMMEDIATE</span>'
            elif narrative.urgency == "THIS_WEEK":
                urgency_badge = '<span style="background:#f59e0b;color:white;padding:2px 8px;border-radius:4px;font-size:11px;">THIS WEEK</span>'
            if urgency_badge:
                st.markdown(urgency_badge, unsafe_allow_html=True)
        
        # Headline
        st.markdown(f"### {narrative.headline}")
        
        # Situation
        st.write(narrative.situation)
        
        # Cause
        if narrative.cause:
            st.markdown(f"**Why:** {narrative.cause}")
        
        # Prediction
        st.info(f"**PREDICTION:** {narrative.prediction}")
        
        # Recommendation
        st.markdown(f"**Recommended Action:** {narrative.recommendation}")
        
        # Confidence
        confidence_color = "#10b981" if narrative.confidence == "HIGH" else "#f59e0b" if narrative.confidence == "MEDIUM" else "#6b7280"
        st.markdown(f"<span style='color:{confidence_color};'>Confidence: {narrative.confidence}</span>", unsafe_allow_html=True)
        
        st.divider()


def _render_red_team(red_team):
    """Render the Red Team vulnerability section."""
    st.markdown("### üõ°Ô∏è Red Team Analysis")
    st.caption("Potential vulnerabilities and blind spots")
    
    if red_team.vulnerabilities:
        for vuln in red_team.vulnerabilities:
            st.warning(vuln)
    
    if red_team.blind_spots:
        st.markdown("**Blind Spots:**")
        for spot in red_team.blind_spots:
            st.write(f"  ‚Ä¢ {spot}")
    
    if red_team.competitor_moves:
        st.markdown("**Possible Competitor Moves:**")
        for move in red_team.competitor_moves:
            st.write(f"  ‚Ä¢ {move}")


def _render_diagnostic_details(brief: DiagnosticBrief):
    """Render diagnostic brief details."""
    
    tab1, tab2, tab3, tab4 = st.tabs(["Profiler", "Calibration", "Forecasts", "Causal"])
    
    with tab1:
        if brief.profiler_vitals:
            st.markdown("**Target Vitals:**")
            for name, vital in brief.profiler_vitals.target_vitals.items():
                status_icon = "‚úÖ" if vital.is_good else "‚ö†Ô∏è" if vital.severity in ["MINOR", "MODERATE"] else "üö®"
                st.write(f"  {status_icon} {name}: {vital.status} ({vital.change_pct:+.1%})" if vital.change_pct else f"  {status_icon} {name}: {vital.status}")
    
    with tab2:
        if brief.calibrated_physics:
            st.text(brief.calibrated_physics.to_prompt_string())
    
    with tab3:
        if brief.forecast_signal:
            st.markdown(f"**Outlook:** {brief.forecast_signal.overall_outlook}")
            for metric, forecast in brief.forecast_signal.forecasts.items():
                change = forecast.expected_change_pct()
                if change:
                    st.write(f"  ‚Ä¢ {metric}: {change:+.1%} expected")
    
    with tab4:
        if brief.causal_signal:
            st.markdown(f"**Primary Drivers:** {', '.join(brief.causal_signal.primary_drivers)}")
            for finding in brief.causal_signal.key_findings:
                st.write(f"  ‚Ä¢ {finding}")


def _render_legacy_mode():
    """Render using legacy analyst if new one not available."""
    st.info("Legacy mode - using original Sherlock Engine")
    # Original implementation would go here
    st.warning("Please upgrade to the new Causal Reasoning Engine for better analysis.")
